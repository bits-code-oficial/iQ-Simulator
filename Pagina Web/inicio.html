<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iQ Simulator - Inversiones Seguras</title>

    <link rel="shortcut icon" href="./assets/images/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="./assets/css/style.css">
    <link rel="stylesheet" href="./assets/css/dashboard_styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700;800;900&display=swap"
        rel="stylesheet">

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <style>
        .main-container-history {
            max-width: 1400px;
            margin: 20px auto;
            padding: 0 20px;
        }
        .history-area {
            background-color: var(--bg-dark-secondary);
            border-radius: 8px;
            padding: 20px;
        }
        .history-title {
            color: var(--text-color-light);
            margin-bottom: 15px;
            font-size: 1.2rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }
        .history-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .history-item {
            display: grid;
            grid-template-columns: 80px 100px 100px 1fr;
            padding: 10px 0;
            border-bottom: 1px dashed var(--border-color);
            font-size: 0.9rem;
        }
        .history-item:last-child {
            border-bottom: none;
        }
        .history-win { color: var(--success-color); }
        .history-loss { color: var(--error-color); }
        .history-amount, .history-profit { font-weight: 600; }
        .placeholder { text-align: center; color: var(--text-color-dim); padding: 10px 0; }
        .ma-indicators {
            display: inline-block;
            margin-left: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        #trendNotification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 4px;
            color: white;
            z-index: 1000;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            min-width: 300px;
            text-align: center;
        }
        
        .chart-area-wrapper {
            position: relative; 
        }
        .chart-controls-inner {
            position: absolute;
            bottom: 15px;
            right: 15px;
            z-index: 10;
            background-color: rgba(30, 30, 30, 0.7);
            border-radius: 4px;
            padding: 5px;
            display: flex;
            gap: 5px;
        }
        .chart-controls-inner button {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-color-light);
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
        }
        .chart-controls-inner button:hover {
            background-color: var(--bg-dark-tertiary);
        }

        #toastContainer {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 20;
            display: flex;
            flex-direction: column-reverse; 
            gap: 10px;
            max-height: 90%;
            overflow-y: hidden;
        }
        .trade-toast {
            padding: 10px 15px;
            border-radius: 4px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            opacity: 1;
            transition: opacity 0.5s, transform 0.5s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
            min-width: 250px;
        }
        .toast-win { background-color: var(--success-color-dark); }
        .toast-loss { background-color: var(--error-color-dark); }
        .toast-info { background-color: var(--primary-color); }

        /* ➡️ ESTILOS PARA LAS LÍNEAS DE OPERACIÓN */
        .trade-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 2px; /* Grosor de la línea */
            z-index: 5;
            transition: opacity 0.5s ease;
        }
        .line-call { background-color: var(--success-color); } /* Línea Verde para Sube */
        .line-put { background-color: var(--error-color); } /* Línea Roja para Baja */
        .line-expiration {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: white;
            z-index: 5;
            right: 0;
        }

    </style>


    <script type="module">
        import { onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";
        import { ref, set, get, update, onValue, push } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-database.js";
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getAuth } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";
        import { getDatabase } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-database.js";

        // ⚠️ CONFIGURACIÓN DE TU PROYECTO FIREBASE ⚠️
        const firebaseConfig = {
            apiKey: "AIzaSyCECR0whwr4quAqB3xYpZa_u-kyKCB9l5E",
            authDomain: "inversiones-cf8d9.firebaseapp.com",
            databaseURL: "https://inversiones-cf8d9-default-rtdb.firebaseio.com",
            projectId: "inversiones-cf8d9",
            storageBucket: "inversiones-cf8d9.firebasestorage.app",
            messagingSenderId: "199869793725",
            appId: "1:199869793725:web:6620015578678e46d73ed4"
        };

        const app = initializeApp(firebaseConfig);
        const authInstance = getAuth(app);
        const dbInstance = getDatabase(app);

        // Referencias al DOM
        const userBalanceSpan = document.getElementById('userBalance');
        const tradeForm = document.getElementById('tradeForm');
        const tradeFeedback = document.getElementById('tradeFeedback');
        const tradeTimeSelect = document.getElementById('tradeTime');
        const chartAreaWrapper = document.querySelector('.chart-area-wrapper'); // Contenedor del gráfico

        let currentUserId = null;
        let myChart = null;
        let chartData = [];
        let currentZoomLevel = 5; 
        const initialValue = 10;
        const dataPoints = 150;
        
        const maPeriodFast = 10;
        const maPeriodSlow = 50;
        let currentTrend = 'Neutral'; 
        
        // ➡️ MODIFICADO: Retorno fijo como en IQ Option (85%)
        const FIXED_PAYOUT_PERCENTAGE = 0.85; 

        // ➡️ NUEVA VARIABLE para rastrear operaciones activas en el gráfico
        let activeTrades = [];


        // Función para calcular la Media Móvil Simple (SMA)
        const calculateSMA = (data, period) => {
             // ... (código SMA sin cambios) ...
             const sma = [];
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    sma.push(null);
                } else {
                    const slice = data.slice(i - period + 1, i + 1);
                    const sum = slice.reduce((a, b) => a + b, 0);
                    sma.push(sum / period);
                }
            }
            return sma;
        };


        // Determinar la Tendencia y Notificar 
        const determineAndNotifyTrend = (maFastData, maSlowData) => {
             // ... (código determineAndNotifyTrend sin cambios) ...
             const latestFastMA = maFastData[maFastData.length - 1];
            const latestSlowMA = maSlowData[maSlowData.length - 1];
            
            if (latestFastMA === null || latestSlowMA === null) {
                currentTrend = 'Neutral';
                trendNotificationElement.style.display = 'none';
                return;
            }

            if (latestFastMA > latestSlowMA) {
                currentTrend = 'Alcista';
                trendNotificationElement.textContent = '🟢 ¡ALERTA! Hay una TENDENCIA ALCISTA.';
                trendNotificationElement.style.backgroundColor = 'var(--success-color-dark)';
                trendNotificationElement.style.display = 'block';
            } else if (latestFastMA < latestSlowMA) {
                currentTrend = 'Bajista';
                trendNotificationElement.textContent = '🔴 ¡ALERTA! Hay una TENDENCIA BAJISTA.';
                trendNotificationElement.style.backgroundColor = 'var(--error-color-dark)';
                trendNotificationElement.style.display = 'block';
            } else {
                currentTrend = 'Neutral';
                trendNotificationElement.style.display = 'none';
            }
        };

        // Mostrar Notificación de Operación (Toast)
        const showTradeToast = (message, type) => {
             // ... (código showTradeToast sin cambios) ...
             const toast = document.createElement('div');
            toast.className = `trade-toast toast-${type}`;
            toast.textContent = message;
            
            toastContainer.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.addEventListener('transitionend', () => {
                    toast.remove();
                });
            }, 5000); 

            const maxToasts = 5;
            while (toastContainer.children.length > maxToasts) {
                toastContainer.removeChild(toastContainer.children[0]); 
            }
        };

        // Formateo de Dinero
        const formatMoney = (amount) => {
             // ... (código formatMoney sin cambios) ...
             return new Intl.NumberFormat('es-ES', {
                style: 'currency',
                currency: 'BOB'
            }).format(amount).replace('BOB', 'Bs');
        };

        // ==================================
        // LÓGICA DE TRADING Y BALANCE
        // ==================================

        // ➡️ FUNCIÓN PARA CREAR LAS LÍNEAS VISUALES DE OPERACIÓN
        const drawTradeLines = (trade) => {
            const chartRect = myChart.canvas.getBoundingClientRect();
            const yAxis = myChart.scales.y;
            
            // Calcula la posición Y en píxeles de la línea de entrada
            const yPixel = yAxis.getPixelForValue(trade.entryPrice);
            
            // Crea la línea horizontal (Entrada)
            const lineDiv = document.createElement('div');
            lineDiv.className = `trade-line line-${trade.type} trade-id-${trade.id}`;
            lineDiv.style.top = `${yPixel - chartRect.top}px`;
            
            // Crea la línea vertical (Expiración)
            const expirationLine = document.createElement('div');
            expirationLine.className = `line-expiration trade-id-${trade.id}`;

            chartAreaWrapper.appendChild(lineDiv);
            chartAreaWrapper.appendChild(expirationLine);
            
            trade.lineElement = lineDiv;
            trade.expirationElement = expirationLine;
        };
        
        // ➡️ FUNCIÓN PARA MOVER LA LÍNEA DE EXPIRACIÓN
        const updateTradeLines = () => {
            const now = Date.now();
            
            activeTrades.forEach(trade => {
                const elapsed = now - trade.startTime;
                const duration = trade.time * 1000;
                const remainingRatio = Math.max(0, 1 - (elapsed / duration));
                
                // Mueve la línea de expiración de izquierda a derecha
                if (trade.expirationElement) {
                    trade.expirationElement.style.right = `${remainingRatio * 100}%`;
                }
            });
        };
        
        // ➡️ FUNCIÓN PRINCIPAL DE GESTIÓN DE LA OPERACIÓN
        const finalizeTrade = async (trade) => {
            // El precio de cierre es el último punto en el gráfico
            const latestPrice = chartData[chartData.length - 1];
            
            const { amount, entryPrice, type, lineElement, expirationElement } = trade;
            
            let win = false;
            if (type === 'call') {
                win = latestPrice > entryPrice;
            } else { // type === 'put'
                win = latestPrice < entryPrice;
            }

            const profitAmount = amount * FIXED_PAYOUT_PERCENTAGE; 
            const fixedLoss = amount; 

            let finalProfit = 0;
            let resultText = '';
            let toastMessage = '';
            let toastType = '';

            if (win) {
                const totalGain = amount + profitAmount;
                await updateBalance(totalGain, null);
                
                finalProfit = profitAmount;
                resultText = 'Ganancia';
                toastMessage = `🎉 ¡GANASTE! +${formatMoney(finalProfit.toFixed(2))}`;
                toastType = 'win';
            } else {
                finalProfit = -fixedLoss; 
                resultText = 'Pérdida';
                toastMessage = `😔 PERDISTE. -${formatMoney(fixedLoss.toFixed(2))}`; 
                toastType = 'loss';
            }
            
            showTradeToast(toastMessage, toastType);

            if (currentUserId) {
                const historyRef = ref(dbInstance, `users/${currentUserId}/history`);
                const tradeRecord = {
                    amount: amount.toFixed(2),
                    type: type,
                    result: resultText,
                    profit: finalProfit.toFixed(2),
                    entry: entryPrice.toFixed(4), 
                    close: latestPrice.toFixed(4),
                    timestamp: Date.now(),
                };
                push(historyRef, tradeRecord);
            }

            // Eliminar líneas visuales del gráfico
            if (lineElement) lineElement.remove();
            if (expirationElement) expirationElement.remove();

            // Eliminar la operación del rastreador
            activeTrades = activeTrades.filter(t => t.id !== trade.id);
        };


        const updateBalance = async (amount, feedbackElement) => {
             // ... (código updateBalance sin cambios) ...
             if (!currentUserId) {
                if (feedbackElement) feedbackElement.textContent = "Error: Usuario no autenticado.";
                return false;
            }

            const userRef = ref(dbInstance, 'users/' + currentUserId);

            try {
                const currentBalance = parseFloat(userBalanceSpan.dataset.balance);
                const newBalance = currentBalance + amount;

                if (newBalance < 0) {
                    if (feedbackElement) feedbackElement.textContent = `Error: Fondos insuficientes. Balance actual: ${formatMoney(currentBalance)}.`;
                    return false;
                }

                await update(userRef, { money: newBalance.toFixed(2) });

                if (feedbackElement) {
                    feedbackElement.textContent = ''; 
                }
                return true;
            } catch (error) {
                if (feedbackElement) feedbackElement.textContent = "❌ Error al procesar la solicitud.";
                return false;
            }
        };

        tradeForm.addEventListener('click', async (e) => {
            if (!e.target.classList.contains('trade-btn')) return;
            e.preventDefault();
            
            tradeFeedback.textContent = 'Procesando...';
            tradeFeedback.style.backgroundColor = 'var(--bg-dark-tertiary)';


            const amountInput = document.getElementById('tradeAmount');
            const amount = parseFloat(amountInput.value);
            const type = e.target.dataset.type;
            const time = parseInt(tradeTimeSelect.value); // Segundos
            
            // Precio de entrada es el último valor del gráfico
            const entryPrice = chartData[chartData.length - 1]; 

            if (isNaN(amount) || amount < 1 || amount > parseFloat(userBalanceSpan.dataset.balance)) {
                tradeFeedback.textContent = "❌ Monto/Fondos inválidos. El monto mínimo es Bs 1.00.";
                return;
            }

            // Deducción inicial (el costo de la operación)
            const deductionSuccess = await updateBalance(-amount, tradeFeedback);
            if (!deductionSuccess) { return; }

            tradeFeedback.textContent = `📈 Operación ${type.toUpperCase()} de ${formatMoney(amount)} iniciada en ${entryPrice.toFixed(4)}...`;
            
            const newTrade = {
                id: Date.now(), 
                amount,
                entryPrice,
                type,
                time,
                startTime: Date.now(),
                lineElement: null,
                expirationElement: null,
            };
            
            // Añadir al rastreador y dibujar las líneas
            activeTrades.push(newTrade);
            drawTradeLines(newTrade);
            
            amountInput.value = '';
            setTimeout(() => {
                finalizeTrade(newTrade); // La operación se resuelve al finalizar el tiempo
                tradeFeedback.textContent = '';
                tradeFeedback.style.backgroundColor = 'transparent';
            }, time * 1000); // Convierte segundos a milisegundos

        });


        // ==================================
        // GRÁFICO DINÁMICO Y ZOOM 
        // ==================================

        const generateChartData = () => {
            // ... (código generateChartData sin cambios) ...
             chartData = [initialValue];
            for (let i = 1; i < dataPoints; i++) {
                let lastValue = chartData[i - 1];
                let change = (Math.random() * 0.3) - 0.15;
                let impulse = (Math.random() > 0.95) ? (Math.random() * 0.8) - 0.4 : 0;

                let newValue = lastValue + change + impulse;
                chartData.push(Math.max(newValue, 5));
            }
        }

        const updateChartZoom = () => {
            // ... (código updateChartZoom sin cambios) ...
             if (!myChart) return;

            currentZoomLevel = Math.max(0.5, Math.min(50, currentZoomLevel));
            const centerValue = chartData[chartData.length - 1] || initialValue;

            myChart.options.scales.y.min = centerValue - (currentZoomLevel / 2);
            myChart.options.scales.y.max = centerValue + (currentZoomLevel / 2);

            myChart.update();
        };

        const createRandomChart = () => {
             // ... (código createRandomChart sin cambios, sin la parte de zoom que ya está abajo) ...
             const ctx = document.getElementById('tickerChart').getContext('2d');
            const labels = Array.from({ length: dataPoints }, (_, i) => `T${i}`);
            
            const maFastData = calculateSMA(chartData, maPeriodFast);
            const maSlowData = calculateSMA(chartData, maPeriodSlow);
            
            determineAndNotifyTrend(maFastData, maSlowData);

            if (myChart) myChart.destroy();

            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Ticker Value (BOB)',
                            data: chartData,
                            borderColor: 'rgb(0, 150, 136)',
                            borderWidth: 2,
                            tension: 0.1,
                            pointRadius: 0,
                            fill: false,
                        },
                        {
                            label: `MA ${maPeriodFast}`,
                            data: maFastData,
                            borderColor: 'rgb(255, 255, 0)', 
                            borderWidth: 1.5,
                            tension: 0.1,
                            pointRadius: 0,
                            fill: false,
                        },
                        {
                            label: `MA ${maPeriodSlow}`,
                            data: maSlowData,
                            borderColor: 'rgb(255, 99, 132)',
                            borderWidth: 1.5,
                            tension: 0.1,
                            pointRadius: 0,
                            fill: false,
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: { label: (context) => `${context.dataset.label}: ${formatMoney(context.parsed.y)}` },
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            titleColor: '#333',
                            bodyColor: '#333',
                            borderColor: '#ccc',
                            borderWidth: 1,
                        }
                    },
                    scales: {
                        x: { display: false, grid: { color: 'rgba(255, 255, 255, 0.05)' } },
                        y: {
                            display: true,
                            beginAtZero: false,
                            min: initialValue - (currentZoomLevel / 2),
                            max: initialValue + (currentZoomLevel / 2),
                            ticks: {
                                callback: (value) => formatMoney(value),
                                color: '#ccc',
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)',
                            }
                        }
                    }
                }
            });
            updateChartZoom();
            updateProbabilityDisplay();
        };

        // Listeners de Zoom
        if (zoomInBtn) zoomInBtn.addEventListener('click', () => {
             // ... (código zoomInBtn sin cambios) ...
             currentZoomLevel = Math.min(50, currentZoomLevel + 2);
            updateChartZoom();
        });

        if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => {
             // ... (código zoomOutBtn sin cambios) ...
             currentZoomLevel = Math.max(0.5, currentZoomLevel - 2);
            updateChartZoom();
        });

        // Simulación de datos en tiempo real (cada 5 segundos)
        setInterval(() => {
            if (myChart) {
                const lastValue = chartData[chartData.length - 1];

                let change = (Math.random() * 0.3) - 0.15;
                let impulse = (Math.random() > 0.95) ? (Math.random() * 0.8) - 0.4 : 0;
                let newValue = lastValue + change + impulse;

                chartData.shift();
                chartData.push(Math.max(newValue, 5));
                
                const maFastData = calculateSMA(chartData, maPeriodFast);
                const maSlowData = calculateSMA(chartData, maPeriodSlow);

                myChart.data.datasets[0].data = chartData;
                myChart.data.datasets[1].data = maFastData;
                myChart.data.datasets[2].data = maSlowData;
                
                determineAndNotifyTrend(maFastData, maSlowData);

                updateChartZoom();
                updateProbabilityDisplay();
                
                // ➡️ Actualizar las líneas de expiración
                updateTradeLines();
            }
        }, 5000);
        // ... (el resto del código HTML y JavaScript permanece sin cambios) ...
    </script>
</body>

</html>
